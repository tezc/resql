# Resql config file

;comment can start like this or
#like this
#inline comments starts with " #" (<space> and #),  or ";"

## Configurations can be overridden on command line by passing arguments
## e.g ./resql --node-log-level=DEBUG --advanced-fsync=false

[node]
# node name must be unique. You cannot change it once the server starts
# No default value. You must specify this option.
name = node0

# bind address and port. Currently unix domain sockets and tcp are supported
# Multiple addresses can be given :
# bind-url = tcp://node0@127.0.0.1:7600 tcp://node0@202.100.51.10:7600
# Default is tcp://127.0.0.1:7600
bind-url = tcp://node0@127.0.0.1:7600 unix:///tmp/resql

# This is the address that other nodes and clients will use to connect to this
# server. If you are not using NAT, it's usually same with bind-url config.
# Default is tcp://127.0.0.1:7600
advertise-url = tcp://node0@127.0.0.1:7600

# Outgoing address and port. Server will use this address and port to open
# connection to other nodes. Useful if you want to deploy firewall rules and
# limit port usage.
# Default is whatever OS assigns when you try to open a connection
#source_addr = 127.0.0.1
#source_port = 9000

# Valid values are DEBUG, INFO, WARN, ERROR, OFF
# Default is INFO
log-level = INFO

# You can give a file path to get logs to a file
# Default is stdout
log-destination = stdout

# Persistence directory
# Default is current working directory of the executable
directory = .

# This option controls if the database will be in memory or on disk. There is
# always a copy of your data on disk (snapshot + WAL files). On a crash or
# any time required, database will start from that copy. This option controls
# current copy of your database and it's solely about performance. It doesn't
# put your data on risk. If database is in memory, operations are completed
# faster. You should try and see if it really makes your operations faster
# though. If it's false, your db is on disk and Resql still uses some amount of
# RAM as it's cache. So, the difference might not be visible for your use-case.
# Default is true
in-memory = true

[cluster]
# Cluster name. All other nodes and clients must be configured with this name
# Default is cluster, this value can't be changed once the server starts
name = cluster

# Node addresses in the cluster. If you want to start a cluster including this
# node, write all nodes here seperated with a comma, e.g:
# nodes = tcp://node0@127.0.0.1:7600 tcp://node1@127.0.0.1:7601 tcp://node2@127.0.0.1:7602
# node names and addresses must match.
# if you want to join this node to a cluster, just add a single node, so this
# node will realize it's not part of a cluster and it will join others.
# Default is tcp://127.0.0.1:7600
nodes = tcp://node0@127.0.0.1:7600

[advanced]
# Resql calls fsync when required to be sure that data makes to the disk. To
# guarantee safety, this option must be true. Otherwise, on an operating system
# crash, you may lose some updates which are waiting to be persisted to the disk
# If you don't care about this, e.g you are using Resql as a cache, you can set
# it to false and avoid disk performance bottleneck.
# Default is true
fsync = true

# If a node doesn't hear from the leader node for a while, it assumes leader
# is down and it starts an election to become the new leader. If leader is
# submitted a long running query or tcp latency between nodes is high, a node
# may think leader is down even though it's not. So, this is a trade-off. If you
# set this value to something low, follower nodes will elect new leader whenever
# leader can't send a message within this interval. If you set this to something
# higher, when leader disconnects from others, followers will wait heartbeat
# milliseconds to elect a new leader. Until then, client operations will be
# blocked.
# Default is 4000 milliseconds.
heartbeat = 4000
